/* When complete, this class should define an object that serves as a mediator
 * for your MazeRunner objects.
 * Your MazeManager must do the following things:
 *
 * 1) get (and store) a maze generated by the mazegenerator.MazeGenerator class
 * 2) Contain a data structure with all of the MazeRunner objects in the Maze
 * 3) Have completed versions of all the methods already declared below
 * 4) Have whatever additional methods are required to produce the desired output.
 *
 *
 * I've included some constants that I've found useful in my reference implementations
 *
 * I've also provided (part of) my version of the run() function, and a few helpful accessors
 *
 */

import java.util.*;
import javax.swing.*;

public class MazeManager {

    private Maze maze;
    private ArrayList<MazeRunner> runners = new ArrayList<>();

    // note that the actual number of rows and columns will be:
    // (number of rows/columns specified * 2) + 1
    // this is because of a detail of how I implemented the Maze class -- I'd fix it,
    // but I'm already late in pushing this assignment out :) -BJA
    public static final int DEFAULT_ROWS = 12;
    public static final int DEFAULT_COLUMNS = 12;

    public static final char EXIT = Maze.EXIT;
    public static final char WALL = Maze.WALL;
    public static final char EMPTY = Maze.EMPTY;
    public static final char RUNNER = '@';

    private int turns = 0;


    public MazeManager() {
        // REPLACE WITH YOUR CODE
        maze = new Maze(DEFAULT_ROWS, DEFAULT_COLUMNS);

    }

    private int getRemaining() {//returns the amount of runners that remain in the maze
        int count = 0;
        for (MazeRunner runner : runners) {
            if (!runner.hasExited()) count += 1;
        }
        return count;
    }

    // this method should return a string showing
    // * the maze
    // * the current turn
    // * the number of runners remaining
    public String toString() {
        // REPLACE WITH YOUR CODE
        //i used a string.format to format my string using %d as an indication of where my integer is placed in the line.
        String output = maze.toString();
        output += String.format("Current turn: %d\n", turns);
        output += String.format("Remaining runners: %d\n", getRemaining());
        return output;
    }

    //helper function to check if a row and column pair is within range for when i add my runner
    private boolean withinRange(int row, int col) {
        return 0 <= col && col < getColumns() && 0 < row && row < getRows();
    }

    public boolean addRunner(MazeRunner runner) {
        // REPLACE WITH YOUR CODE
        int col = runner.getColumn();
        int row = runner.getRow();
        if (withinRange(row, col) && maze.getCharacterAt(row, col) == Maze.EMPTY) {
            maze.setCharacterAt(runner.getRow(), runner.getColumn(), RUNNER);
            runners.add(runner);
            return true;
        } else {
            return false;
        }
    }

    public int getRows() {
        return this.maze.getRows();
    }

    public int getColumns() {
        return this.maze.getColumns();
    }

    //the following are helpers for getting the indexes of row and column for a specific direction just to make my code
    // for move simpler and easy to understand

    private int getNextRow(int row, Direction dir) {
        if (dir == Direction.NORTH) {
            return row - 1;
        } else if (dir == Direction.SOUTH) {
            return row + 1;
        } else {
            return row;
        }
    }

    private int getNextCol(int col, Direction dir) {
        if (dir == Direction.EAST) {
            return col + 1;
        } else if (dir == Direction.WEST) {
            return col - 1;
        } else {
            return col;
        }
    }

    // This method attempts to move the runner in the requested direction.
    // if the direction is HERE, the runner waits on its current
    // square.
    // returns false if move is unsuccessful, true if successful
    private boolean move(MazeRunner runner, Direction runnerDirection) {
        // REPLACE WITH YOUR CODE
        int row = runner.getRow();
        int col = runner.getColumn();
        switch (look(runner, runnerDirection)) {
            case EMPTY:
                maze.setCharacterAt(row, col, EMPTY);
                runner.setRow(getNextRow(row, runnerDirection));
                runner.setColumn(getNextCol(col, runnerDirection));
                maze.setCharacterAt(runner.getRow(), runner.getColumn(), RUNNER);
                return true;
            case EXIT:
                maze.setCharacterAt(row, col, EMPTY);
                runner.setExited(turns);
                return true;
            default:
                return false;
        }
    }

    // this method should return the contents of the square that's to the requested
    // direction from the runner
    public MazeSquare look(MazeRunner runner, Direction direction) {
        // REPLACE WITH YOUR CODE
        int col = getNextCol(runner.getColumn(), direction);
        int row = getNextRow(runner.getRow(), direction);
        if(withinRange(row,col)) {
            switch (maze.getCharacterAt(row, col)) {
                case Maze.EMPTY:
                    return MazeSquare.EMPTY;
                case Maze.WALL:
                    return MazeSquare.WALL;
                case Maze.EXIT:
                    return MazeSquare.EXIT;
                case RUNNER:
                    return MazeSquare.RUNNER;
            }
        }

        return MazeSquare.ERROR;
    }

    // this method should ask all of the MazeRunner objects in the
    // maze to move, and then use their responses to call the (private) move method.
    // Returns true if there are still runners moving around, false if all
    // runners have exited
    private boolean update() {
        // REPLACE WITH YOUR CODE
        turns += 1;
        for (MazeRunner runner : runners) {
            if (!runner.hasExited()) {
                move(runner, runner.takeTurn());
            }
        }
        return getRemaining() != 0;
    }

    // calls update over and over again until either all runners have exited or
    // maxTurns have passed. Returns true if all runners exited, false otherwise

    // if interactive is true, will show maze's current state and pause after each
    // update. otherwise, runs until finishes.
    private boolean run(int maxTurns, boolean interactive) {

        Scanner scanner = new Scanner(System.in);

        // most of the work here is done in the loop control condition (i.e. that call to update())
        while (turns < maxTurns && update()) {
            if (interactive) {
                System.out.println(this);
                System.out.println("press c to continue, q to quit"); // honestly, anything but q continues...
                String input = scanner.next();
                if (input.charAt(0) == 'c') {
                    continue;
                }
                if (input.charAt(0) == 'q') {
                    break;
                }
            }
        }

        System.out.println(this);


        // YOUR ADDITIONAL CODE FOR THE run() METHOD SHOULD APPEAR BELOW
        // Note that for each one of your runners, you should print the turn the runner exited
        for (int i = 0; i < runners.size(); i++) {
            if (runners.get(i).hasExited()) {
                System.out.printf("Runner %d (%s) finished in %d turns.\n", i + 1, runners.get(i).getName(), runners.get(i).turnExited());
            } else {
                System.out.printf("Runner %d (%s) hasn't finished yet.\n", i + 1, runners.get(i).getName());
            }
        }
        return getRemaining() == 0;
    }



        // This method may be useful for starting to test your MazeManager
        // I encourage you to add additional static testing methods as you finish more parts of the
        // assignment
        private static void testBartlebys(MazeManager manager){

            Random rng = new Random();
            for (int i = 1; i < 10; i++) {
                BartlebyBot bartleby = new BartlebyBot(1, rng.nextInt(manager.getColumns()), manager);

                boolean addSuccessful = manager.addRunner(bartleby);
                if (addSuccessful) {
                    System.out.println("Successfully added " + bartleby.getName() + "at (1, " + bartleby.getColumn() + ")");
                } else {
                    System.out.println("Failed to add " + bartleby.getName() + "at (1, " + bartleby.getColumn() + ")");
                }
            }
            System.out.println(manager.toString());
            manager.run(10, false);
        }
        private static void testRobots(){
            Random rng = new Random();

            for(int i = 0; i < 3; i++){
                int count = 0;
                MazeManager manager = new MazeManager();
                MazeRunner bot = null;
                while (count<15){
                    switch(i % 3){
                        case 0:
                            bot = new RandomBot(rng.nextInt(manager.getRows()), rng.nextInt(manager.getColumns()),manager);
                            break;
                        case 1:
                            bot = new PrudentBot(rng.nextInt(manager.getRows()), rng.nextInt(manager.getColumns()),manager);
                            break;
                        case 2:
                            bot = new CleverBot(rng.nextInt(manager.getRows()), rng.nextInt(manager.getColumns()),manager);
                            break;
                    }
                    if(manager.addRunner(bot)) count++;
                }
                System.out.printf("\nSuccessfully added %d %ss\n\n", count, bot.getName());
                System.out.println(manager.toString());
                manager.run(10000, false);
            }
        }

        public static void main (String[]args){
            // YOUR CODE HERE. I encourage you to write static testing functions that your main function
            // calls -- test your code until you're satisfied it works reliably.
            testRobots();
        }
    }

