package mazegenerator;/* uses sedgewick's implementation of union-find to build a tree, which is in turn used
 * to generate a maze.
 *
 *
 * ===
 * DO NOT EDIT THIS FILE
 * ===
 */

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Random;

public class MazeGenerator {

    private static int DEFAULT_ROWS = 8;
    private static int DEFAULT_COLUMNS = 8;


    private HashSet<Edge> edges = new HashSet<>();
    private HashSet<Pair> nodes = new HashSet<>();
    private Random rng;
    private UF uf;

    private int rows;
    private int columns;



    public MazeGenerator(){
        this(DEFAULT_ROWS, DEFAULT_COLUMNS);
    }

    public MazeGenerator(Random rng){
        this(DEFAULT_ROWS, DEFAULT_COLUMNS, rng);

    }

    public MazeGenerator(int rows, int columns){
        this(rows, columns, new Random());
    }

    // used for testing: provide rng with known seed.
    public MazeGenerator(int rows, int columns, Random rng){
        this.rng = rng;
        this.rows = rows;
        this.columns = columns;
        makeTree();
    }

    // assumes undirected graph
    public boolean hasEdge(Pair first, Pair second){
        Edge to = new Edge(first, second);
        Edge from = new Edge(second, first);
        return edges.contains(from) || edges.contains(to);
    }

    public MazeGenerator(long seed){
        rng.setSeed(seed);
        makeTree();
    }


    public int getRows() {
        return rows;
    }

    public int getColumns() {
        return columns;
    }

    private void makeTree(){
        uf = new UF(rows * columns);
        while (uf.count() != 1){
            Pair first = new Pair(rng.nextInt(rows * columns), columns);
            Pair second = getRandomAdjacentPair(first);
            if(knockDown(first.getIndex(), second.getIndex())){
                edges.add(new Edge(first, second));
            }
        }
    }

    private void printEdges(){
        for (Edge edge: edges){
            System.out.println(edge);
        }
    }

    private boolean knockDown(int first, int second){
        if (uf.find(first) == uf.find(second)){
            return false;
        }
        uf.union(first, second);
        return true;
    }

    private Pair getRandomAdjacentPair(Pair first){
        int row = first.getRow();
        int column = first.getColumn();

        ArrayList<Pair> adjacents = new ArrayList<>();

        if (row > 0){
            adjacents.add(new Pair(row - 1, column, columns));
        }
        if (row < rows - 1){
            adjacents.add(new Pair(row + 1, column, columns));
        }
        if (column > 0){
            adjacents.add(new Pair(row, column - 1, columns));
        }
        if (column < columns - 1){
            adjacents.add(new Pair(row, column + 1, columns));
        }
        return adjacents.get(rng.nextInt(adjacents.size()));
    }
}
